{"ast":null,"code":"var _jsxFileName = \"/home/aali7075/summer_projects/PathPlanningWebsite/src/ppviz/PathPlannerViz.jsx\";\nimport React, { PureComponent } from \"react\";\nimport Node from \"./node/node\"; //import Navbar from \"react-bootstrap/Navbar\";\n\nimport SidebarExampleVisible from \"/Navbar\";\nimport \"./PathPlannerViz.css\";\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35; //Create an  struct object for the Node\n\nconst CreateNode = (col_, row_) => {\n  // ES6 arrow style used to inherit from context of function\n  return {\n    col_,\n    row_,\n    is_start_: row_ == START_NODE_ROW && col_ == START_NODE_COL,\n    is_end_: row_ == FINISH_NODE_ROW && col_ == FINISH_NODE_COL,\n    is_wall_: false,\n    // equivalent to createNode.is_wall= false\n    is_visited_: false,\n    previous_node: null,\n    distance_: Infinity\n  };\n};\n\nconst GetInitialGrid = () => {\n  const grid = []; // Initalize 2d array will be size 20,50\n\n  for (let row = 0; row < 20; row++) {\n    const currentRow = []; //Intialize row\n\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(CreateNode(col, row));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst ToggledWall = (grid_, row_, col_) => {\n  const new_grid = grid_.slice();\n  const node = new_grid[row_][col_];\n\n  if (!node.is_wall_ && !node.is_start_ && !node.is_end_) {\n    const new_node = { ...node,\n      // using spreads syntax to create a copy of object\n      is_wall_: !node.is_wall_\n    };\n    new_grid[row_][col_] = new_node;\n  }\n\n  return new_grid;\n}; //Created as a pure compoenent for render optimization\n\n\nexport default class PathfindingVisualizer extends PureComponent {\n  constructor() {\n    super(); //nochild components so no need to pass properties\n\n    this.state = {\n      grid_: [],\n      mouse_is_pressed_: false // check whether mosue is held down\n\n    };\n  }\n  /*\n  We only want to render part of the grid\n  this funciton always updates as soon as the state changes. (Built in function)\n  It did reduce the amount of renders but did not give us the fluid change that we needed.\n  To properly use shouldComponentUpdate we would need to change our props so that\n  not all the components were encapsulated inside the grid or find a differnt structure\n  to allow for partial renders inside of a state array.\n    shouldComponentUpdate(nextProps, nextState) {\n  return (this.state.grid_ != nextState.grid_) && (this.mouse_is_pressed_) ;\n  }\n  */\n\n\n  componentDidMount() {\n    const grid_ = GetInitialGrid();\n    this.setState({\n      grid_\n    }); ///following syntax of this.state\n  }\n\n  handleMouseDown(row_, col_) {\n    const newGrid = ToggledWall(this.state.grid_, row_, col_); //const newComponent = newGrid[row_][col_];\n\n    this.setState({\n      grid_: newGrid,\n      mouse_is_pressed_: true\n    });\n  }\n\n  handleMouseEnter(row_, col_) {\n    if (!this.state.mouse_is_pressed_) return;\n    const newGrid = ToggledWall(this.state.grid_, row_, col_);\n    this.setState({\n      grid: newGrid\n    });\n  }\n\n  handleMouseUp() {\n    this.setState({\n      mouse_is_pressed_: false\n    });\n  }\n\n  handleDragOver(ev) {\n    ev.preventDefault();\n  }\n\n  render() {\n    const {\n      grid_\n    } = this.state; //grabbing attributes from this.state\n\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 109,\n        columnNumber: 7\n      }\n    }, grid_.map((row_, row_idx) => {\n      //gridmap grab each row and the row index of each row\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: row_idx,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 113,\n          columnNumber: 13\n        }\n      }, row_.map((node, node_idx) => {\n        const {\n          row_,\n          col_,\n          is_end_,\n          is_start_,\n          is_wall_\n        } = node;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: node_idx,\n          row_: row_,\n          col_: col_,\n          is_start_: is_start_,\n          is_end_: is_end_,\n          is_wall_: is_wall_,\n          onMouseDown: (row_, col_) => this.handleMouseDown(row_, col_),\n          onMouseEnter: (row_, col_) => this.handleMouseEnter(row_, col_),\n          onMouseUp: () => this.handleMouseUp(),\n          onDragOver: e => this.handleDragOver(e),\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 117,\n            columnNumber: 19\n          }\n        });\n      }));\n    }));\n  }\n\n}","map":{"version":3,"sources":["/home/aali7075/summer_projects/PathPlanningWebsite/src/ppviz/PathPlannerViz.jsx"],"names":["React","PureComponent","Node","SidebarExampleVisible","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","CreateNode","col_","row_","is_start_","is_end_","is_wall_","is_visited_","previous_node","distance_","Infinity","GetInitialGrid","grid","row","currentRow","col","push","ToggledWall","grid_","new_grid","slice","node","new_node","PathfindingVisualizer","constructor","state","mouse_is_pressed_","componentDidMount","setState","handleMouseDown","newGrid","handleMouseEnter","handleMouseUp","handleDragOver","ev","preventDefault","render","map","row_idx","node_idx","e"],"mappings":"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","sourcesContent":["import React, { PureComponent } from \"react\";\nimport Node from \"./node/node\";\n//import Navbar from \"react-bootstrap/Navbar\";\nimport SidebarExampleVisible from \"/Navbar\";\n\nimport \"./PathPlannerViz.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\n//Create an  struct object for the Node\nconst CreateNode = (col_, row_) => {\n  // ES6 arrow style used to inherit from context of function\n  return {\n    col_,\n    row_,\n    is_start_: row_ == START_NODE_ROW && col_ == START_NODE_COL,\n    is_end_: row_ == FINISH_NODE_ROW && col_ == FINISH_NODE_COL,\n    is_wall_: false, // equivalent to createNode.is_wall= false\n    is_visited_: false,\n    previous_node: null,\n    distance_: Infinity,\n  };\n};\n\nconst GetInitialGrid = () => {\n  const grid = []; // Initalize 2d array will be size 20,50\n  for (let row = 0; row < 20; row++) {\n    const currentRow = []; //Intialize row\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(CreateNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst ToggledWall = (grid_, row_, col_) => {\n  const new_grid = grid_.slice();\n  const node = new_grid[row_][col_];\n  if (!node.is_wall_ && !node.is_start_ && !node.is_end_) {\n    const new_node = {\n      ...node, // using spreads syntax to create a copy of object\n      is_wall_: !node.is_wall_,\n    };\n    new_grid[row_][col_] = new_node;\n  }\n  return new_grid;\n};\n\n//Created as a pure compoenent for render optimization\nexport default class PathfindingVisualizer extends PureComponent {\n  constructor() {\n    super(); //nochild components so no need to pass properties\n    this.state = {\n      grid_: [],\n      mouse_is_pressed_: false, // check whether mosue is held down\n    };\n  }\n\n  /*\n\nWe only want to render part of the grid\nthis funciton always updates as soon as the state changes. (Built in function)\nIt did reduce the amount of renders but did not give us the fluid change that we needed.\nTo properly use shouldComponentUpdate we would need to change our props so that\nnot all the components were encapsulated inside the grid or find a differnt structure\nto allow for partial renders inside of a state array.\n\n\n  shouldComponentUpdate(nextProps, nextState) {\n  return (this.state.grid_ != nextState.grid_) && (this.mouse_is_pressed_) ;\n}\n\n*/\n\n  componentDidMount() {\n    const grid_ = GetInitialGrid();\n    this.setState({ grid_ }); ///following syntax of this.state\n  }\n\n  handleMouseDown(row_, col_) {\n    const newGrid = ToggledWall(this.state.grid_, row_, col_);\n    //const newComponent = newGrid[row_][col_];\n    this.setState({ grid_: newGrid, mouse_is_pressed_: true });\n  }\n\n  handleMouseEnter(row_, col_) {\n    if (!this.state.mouse_is_pressed_) return;\n    const newGrid = ToggledWall(this.state.grid_, row_, col_);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouse_is_pressed_: false });\n  }\n\n  handleDragOver(ev) {\n    ev.preventDefault();\n  }\n\n  render() {\n    const { grid_ } = this.state;\n    //grabbing attributes from this.state\n\n    return (\n      <div className=\"grid\">\n        {grid_.map((row_, row_idx) => {\n          //gridmap grab each row and the row index of each row\n          return (\n            <div key={row_idx}>\n              {row_.map((node, node_idx) => {\n                const { row_, col_, is_end_, is_start_, is_wall_ } = node;\n                return (\n                  <Node\n                    key={node_idx}\n                    row_={row_}\n                    col_={col_}\n                    is_start_={is_start_}\n                    is_end_={is_end_}\n                    is_wall_={is_wall_}\n                    onMouseDown={(row_, col_) =>\n                      this.handleMouseDown(row_, col_)\n                    }\n                    onMouseEnter={(row_, col_) =>\n                      this.handleMouseEnter(row_, col_)\n                    }\n                    onMouseUp={() => this.handleMouseUp()}\n                    onDragOver={(e) => this.handleDragOver(e)}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}